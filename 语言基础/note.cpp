/*
                    -->字符串处理函数<--
->getchar()   获取一个字符
  gets() scanf()  由于这两个函数无法知道读取数据的长度，再读入后存入数组时，易引起越界。
  gets()允许输入空格，scanf()不允许
->fgets(arr,100,stdin) 字符指针，大小，文件流 将100个输入到arr中，从标准输入流中
  如果输入的大小小于原始指针对应区域大小，会在字符串输入完成时，自动加上/n/0，即字符串结束标志
  如果输入大小大于等于，则会自动加上/0，不会加上/n
  fgets是安全的，会接收 固定大小的字符串。始终会加入/0加入，以结束字符串。
->scanf("%[\n]",arr)接收可以加空格,回车结束
  scanf("%d %d %d ",&a,&b,&c)实际输入时必须一一对应，因此在接收字符时，不添加任何字符，空格除外
  scanf("%4d%4d%4d",&a,&b,&c)每个里面只接收4位，其实以上考虑参照正则匹配。
  scanf("%1s&2s")，第一个接收1个字符，第二个接收2个字符
  scanf("%*d%s",&arr),忽略数字接收字符串，即屏蔽某种类型
->strlen() 求出一个字符串的长度  ，需要导入string.h的库，其算出来的忽略/0及其后面的所有，不忽略/n，但不能处理字符数组
->strcpy(arr2,arr1)，参数（目标字符串，源字符串），字符串拷贝的时候会把/0也拷贝，如果返回值不为NULL说明拷贝成功
->strncpy(目标字符串，源字符串，拷贝个数)，叫做有限拷贝，有限拷贝不会拷贝/0,需要在拷贝结束后加一个'/0'
->strcat(目标字符串,源字符串)追加拷贝，将源字符串追加到目标字符串中，但要注意目标字符串追加后可能会越界
->strncat(目标字符串，源字符串，追加个数)，叫做有限追加，有限追加会将/0追加到字符串结尾，因此不需要再次手动追加
->strcmp（arr1,arr2），字符串比较,比较的是/0之前的所有与字符,返回值有三种，0，大于0,小于0,不同系统中返回值不同，有的返回的是ASCII码的差值，所以一般只有相等的情况下最可信。即，返回值是0的时候可信。
->strncmp(arr1,arr2，长度)，有限比较，与前面几个是否相同。
->sprintf()与sscanf(),例如，int a = 123;char arr[]="hello"，sprintf(dest,"%s  %d",arr,a);将arr和a连接起来，放入到dest中，并没有向屏幕输出的功能。返回值是存入的个数，如果失败返回值是-1
->sscanf(dest,"%d %s",&a,&b),从dest中取出数字和字符串，分别放入a,b中，返回值与上面类似。
->strchr（arr,ch）,从arr字符串中获取ch（一个字符）第一次出现的位置（是一个指针），如果失败或者没有返回NULL
->strstr(arr1,arr2),从arr1中查找arr2第一次出现的位置，返回值是指针。
->strtok(字符串，分割符号或字符串)分割字符串，其本质是将切割点替换为\0。循环分割，后面一次分割，p=strtok(NULL,".");这么写。
->atoi（），atol()，两个函数可以将字符“100”转化为数字100，当字符串中的数据必须在前面，前面不能有字符。

                           -->多文件联合编程<--
->主文件，写main函数等
->头文件的作用：1.函数、变量的声明
                2.系统库的调用
   #program once 只调用一次
   #ifndef _XXX_XX_H_
   #define _XXX_XX_H_


   #endif

*/